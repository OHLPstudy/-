## 오다은
### 이론 문제
다음은 Java Stream의 특징 중 (A)에 대한 설명이다. 주어진 질문에 대한 답변을 적으시오.  

```
Java Stream은 데이터 처리 방식에서 (A) 특성을 가지고 있다.
이는 중간 연산이 즉시 실행되지 않고, (B) 연산이 호출될 때 실행되는 방식을 말한다.
이 특성을 통해 Java Stream은 (C) 를 최적화할 수 있으며, 불필요한 데이터 처리나 연산을 방지할 수 있다.
```

**1. (A), (B), (C)에 들어갈 단어**:

- (A): **지연 연산 (Lazy Evaluation)**
- (B): **최종 연산 (Terminal Operation)**
- (C): **성능 (Performance)**

---

**2. Lazy Evaluation의 개념과 작동 원리**:

- **개념**:
    - **Lazy Evaluation**은 Stream의 **“필요할 때만 처리”**하는 방식이다.
    - **중간 연산(`filter`, `map` 등)**은 데이터 처리 규칙만 정의하며, 실제 데이터 처리는 **최종 연산(`collect`, `forEach` 등)**이 호출될 때만 실행된다.
    - Stream은 불필요한 데이터 연산을 건너뛰고, 필요한 데이터만 처리하여 **효율성을 극대화한다.**
- **작동 원리**:
    1. **Stream 생성**
        - 데이터 소스(List, Set, Map, Array 등)에서 Stream 객체를 생성한다.
        
        ```java
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        Stream<Integer> stream = numbers.stream();
        // stream() 또는 Stream.of()를 통해 데이터 소스 연결
        ```
        
    2. **중간 연산**
        - Stream 파이프라인에서 데이터를 처리할 규칙을 설정하는 단계
        - 실제 데이터가 처리되지 않으며, 연산 규칙이 파이프라인에 쌓이는 과정이다.
        - 중간 연산은 항상 Lazy하게 동작하며, 최종 연산이 호출되기 전까지 실행되지 않는다.
        
        ```java
        Stream<Integer> filteredStream = stream.filter(n -> n % 2 == 0); // 짝수만 필터링 규칙 정의
        Stream<Integer> mappedStream = filteredStream.map(n -> n * 2); // 필터링된 데이터에서 2를 곱하는 규칙 추가
        // 아직 데이터 처리는 실행되지 않음
        ```
        
    3. **최종 연산**
        - 최종 연산이 호출되면 Stream은 파이프라인에 쌓인 중간 연산 규칙을 실행하며 데이터를 처리한다.
        - 이때 데이터를 하나씩 처리하며 조건에 맞는 연산만 수행한다.
        
        ```java
        mappedStream.forEach(System.out::println);
        // forEach는 최종 연산으로, 데이터를 처리하면서 출력한다.
        // 중간 연산 filter와 map이 순서대로 실행된다.
        ```
        

---

**3. Lazy Evaluation이 성능 최적화에 어떻게 기여하는가?**

- **필요한 데이터만 처리**
    - Lazy Evaluation은 데이터를 하나씩 처리하면서 조건에 맞는 데이터만 연산한다.
    - 이를 통해 불필요한 데이터 처리를 건너뛰어 CPU와 메모리 사용량을 줄인다.
- **조기 종료 기능**
    - 특정 조건(`findFirst`, `limit`)이 만족되면 이후 데이터를 더 이상 처리하지 않고, 연산을 종료한다.
    - 이는 대규모 데이터 처리 시 연산 비용을 크게 절약한다.
- **파이프라인 최적화**
    - 여러 중간 연산이 결합되어 Stream 내부적으로 최적의 경로로 데이터가 처리된다.
    - 이로 인해 연산 횟수가 줄어들어 성능이 향상된다.

```java
List<Integer> numbers = new ArrayList<>();
for (int i = 1; i <= 1_000_000; i++) {
    numbers.add(i);
}

numbers.stream()
    .filter(n -> n % 2 == 0) // 짝수 필터링
    .limit(3)                // 처음 3개만 가져오기
    .forEach(System.out::println);

// 짝수 3개를 찾은 시점에서 연산을 종료한다. (limit)
// 1,000,000개의 데이터를 모두 처리하지 않고 필요한 데이터만 연산한다.
```

```java
List<Integer> numbers = List.of(1, 3, 5, 6, 8, 10);

Integer firstEven = numbers.stream()
    .filter(n -> n % 2 == 0) // 짝수만 필터링
    .findFirst()             // 첫 번째 짝수 반환
    .orElse(null);

System.out.println(firstEven); // 출력: 6

// 조건을 만족하는 첫 번째 짝수(6)을 찾은 후 연산을 종료한다. (findFirst)
// 8과 10 같은 나머지 데이터는 처리하지 않는다. 
```


### 코드 문제
아래 코드는 병렬 스트림을 사용하여 데이터를 처리하지만, 실행 결과가 출력되지 않는다. 오류 발생 원인을 분석하고 이를 수정하시오.

또한, 결과를 정렬하여 출력하도록 코드를 작성하고, 수정된 코드의 출력 결과를 예측하시오.

+) 조건 추가

현재 filter 조건은 모든 배열 요소를 필터링합니다. 김씨 성을 가진 사람 **걸러** 주세요 ^^

(김씨 사람만 **제외**하는 조건으로 필터링)

```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("오다은", "황진영", "이석운", "박대신", "김기백");

        names.parallelStream()
            .filter(name -> name.length() > 2)
            .map(name -> name + " 씨");
    }
}
```

**[정답 및 풀이]**

**오류 원인**

- `parallelStream()`에서 중간 연산만 존재하고, 최종 연산이 없어서 데이터가 처리되지 않는다.
- Stream의 중간 연산(`filter`, `map`)은 최종 연산이 호출되지 않으면 실행되지 않는 **Lazy Evaluation** 특성을 가진다.
- 즉, `filter`, `map`은 중간 연산이므로 실제로 실행되지 않고, 데이터는 처리되지 않는 상태로 남아 있다.

---

**수정된 코드**

```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("오다은", "황진영", "이석운", "박대신", "김기백");

        // 병렬 스트림 생성
        List<String> result = names.parallelStream()
            .filter(name -> !name.startsWith("김")) // 김씨 제거 ㅋ
            .map(name -> name + "씨") // 이름 뒤에 "씨" 추가
            .sorted() // 결과 정렬
            .toList(); // 결과를 리스트로 수집

        // 정렬된 결과 출력
        result.forEach(System.out::println);
    }
}
```

**수정된 코드의 동작**

1. **병렬 스트림 생성**:
    - `parallelStream()`은 병렬로 데이터를 처리할 Stream 생성
2. **중간 연산**:
    - 김씨 제거
        - `filter(name -> !name.startsWith("김"))`
    - 씨 추가
        - `map(name -> name + "씨")`
    - 정렬
        - `sorted()`
3. **최종 연산**:
    - 결과 수집
        - `toList()`
        - `collect(Collectors.toList())` (난 16버전이라서 toList 씀 ㅎ)
    - 결과 출력
    - `forEach(System.out::println)`

---

**출력 결과**

```java
박대신 씨
오다은 씨
이석운 씨
황진영 씨
```

## 황진영
### 이론 문제


### 코드 문제


## 이석운
### 이론 문제


### 코드 문제


## 박대신
### 이론 문제


### 코드 문제

