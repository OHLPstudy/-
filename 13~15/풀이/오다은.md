## 오다은
### 이론문제 
#### 데드락 발생 이유

데드락이 발생하려면 데드락 발생 조건 4가지가 모두 만족되어야 한다.

**데드락 발생 조건 4가지 (Coffman 조건)**

1. 상호 배제 (Mutual Exclusion)
    - 자원(`lock1`, `lock2`)은 한 번에 하나의 스레드만 사용할 수 있다.
    - 예제 코드에서 `synchronized` 블록이 사용되고 있으므로, 락(`lock1`, `lock2` )은 상호 배제를 보장한다.
2. 점유 대기 (Hold and Wait)
    - 스레드가 이미 할당된 자원을 점유한 상태에서, 추가 자원을 요청하며 대기한다.
    - 예제 코드에서 `Thread-1` 은 `lock1` 을 점유한 상태에서 `lock2` 를 요청하고, `Thread-2` 는 `lock2` 를 점유한 상태에서 `lock1` 을 요청한다.
3. 비선점 (No Preemption)
    - 자원을 점유한 스레드는 스스로 해제할 때까지 해당 자원을 강제로 빼앗을 수 없다.
    - 예제 코드에서 `synchronized` 블록이 사용되므로, 락을 점유한 스레드가 락을 스스로 해제하기 전에는 다른 스레드가 해당 락을 점유할 수 없다.
4. 순환 대기 (Circular Wait)
    - 여러 스레드가 자원을 점유하고, 서로가 점유한 자원을 기다리는 원형 대기 상태가 형성된다.
    - 예제에서는 다음과 같은 순환 대기가 발생한다.
        - Thread-1: `lock1`  → `lock2` 대기
        - Thread-2: `lock2` → `lock1` 대기

따라서 예제 코드에서 데드락이 발생하는 이유는 위 4가지 조건이 모두 만족되기 때문이다.

1. Thread-1: `lock1` 을 점유한 상태에서 `lock2` 를 기다린다.
2. Thread-2: `lock2` 를 점유한 상태에서 `lock1` 을 기다린다.
3. 두 스레드는 서로 상대방이 점유한 락을 기다리며 무한 대기 상태에 빠진다. (순환 대기)

#### 데드락 방지 및 해결 방법

데드락을 방지하려면 위 4가지 조건 중 하나 이상을 깨트려야 한다.

1. 락 획득 순서 통일 ( Lock Ordering) → 순환 대기 상태 방지
    - 모든 스레드가 자원을 요청할 때 항상 동일한 순서로 자원을 요청하도록 강제한다.
    - 예: 항상 `lock1` 을 먼저 획득한 뒤, `lock2` 를 요청하면 데드락을 방지할 수 있다.
    
    ```java
    public class DeadlockSolution {
        private static final Object lock1 = new Object();
        private static final Object lock2 = new Object();
    
        public static void main(String[] args) {
            Thread thread1 = new Thread(() -> {
                synchronized (lock1) {
                    System.out.println("Thread-1 lock1");
                    synchronized (lock2) {
                        System.out.println("Thread-1 lock2");
                    }
                }
            });
    
            Thread thread2 = new Thread(() -> {
                synchronized (lock1) { // 변경점: Thread-2도 lock2 대신 항상 lock1을 먼저 요청
                    System.out.println("Thread-2 lock1");
                    synchronized (lock2) {
                        System.out.println("Thread-2 lock2");
                    }
                }
            });
    
            thread1.start();
            thread2.start();
        }
    }
    ```
    
2. Try-Lock으로 타임아웃 설정
    - `ReentrantLock` 의 `tryLock()` 메서드를 사용하여 타임아웃 시간을 설정하면, 스레드가 락을 얻을 수 없는 경우 대기를 중단하고 다른 작업을 수행할 수 있다.
    - 즉, 스레드가 락을 획득하기 위해 기다리는 시간을 정해 놓는 것이며, 작업 처리하기 위해 락을 오래 잡고 있어도 Lock 타임아웃에 걸려서 포기할 수도 있다는 것에 유의해야 한다.
    - 동기화 블록 진입에 대해서는 타임아웃을 설정할 수 없다는 한계가 있으며, 이를 위해서 커스텀 락 클래스를 만들거나 java.util.concurrency를 사용해야 함
    - 변경점: 락 요청 시 즉시 반환하거나 타임아웃 설정으로 무한 대기를 방지
    
    ```java
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    public class DeadlockSolutionWithTimeout {
        private static final Lock lock1 = new ReentrantLock();
        private static final Lock lock2 = new ReentrantLock();
    
        public static void main(String[] args) {
            Thread thread1 = new Thread(() -> {
                try {
                    if (lock1.tryLock() && lock2.tryLock()) { // 락을 요청하고, 실패하면 대기를 중단
                        System.out.println("Thread-1: lock1, lock2 모두 획득");
                    }
                } finally {
                    lock1.unlock();
                    lock2.unlock();
                }
            });
    
            Thread thread2 = new Thread(() -> {
                try {
                    if (lock2.tryLock() && lock1.tryLock()) {
                        System.out.println("Thread-2: lock1, lock2 모두 획득");
                    }
                } finally {
                    lock1.unlock();
                    lock2.unlock();
                }
            });
    
            thread1.start();
            thread2.start();
        }
    }
    
    ```
    
3. 자원 할당 그래프 (Resource Allocation Graph)
    - 자원 요청과 점유 관계를 그래프로 표현하여, 순환 대기가 발생하는지 확인하고 사전에 방지한다.
4. 교착 상태 예방 알고리즘
    - 은행원 알고리즘(Banker’s Algorithm): 시스템 자원을 동적으로 할당하고, 교착 상태가 발생하지 않는지 확인하여 안전하게 자원을 할당한다.
---

### 코드문제
**문제 상황**

- 두 개의 `List` 를 받아 하나의 새로운 리스트로 병합하려는 메서드가 있다.
- 현재 메서드는 와일드카드(`? extends Product`)를 사용하여 구현되어 있는데, 이는 다음과 같은 문제를 야기한다:
    1. **타입 안정성 부족**: 새로운 요소를 추가하거나 수정하려 할 때 컴파일 에러가 발생한다.
    2. **확장성 부족**: 반환 타입이 `List<? extends Product>` 라서 호출 시 타입 캐스팅이 필요하다.
- *한마디  요약: 이 메서드는 리스트를 병합하려고 하지만, 와일드카드를 사용해서 타입 안정성이 부족한 문제가 있다.*

---

**에러 원인 분석**

- 와일드카드(`? extends Product`)는 **불공변성**을 갖는다.
    - `List<? extends Product>`는 `Product` 또는 그 하위 타입을 포함하는 리스트를 의미하지만, 읽기만 허용되고 요소를 추가하거나 수정할 수 없다.
    - 이는 타입 안정성을 보장하기 위한 설계이다.
- 이러한 특성 때문에 `newList.addAll(list2)`에서 컴파일 에러가 발생한다. 컴파일러는 `list2`와 `newList`의 정확한 타입 일치를 확인할 수 없기 때문이다.
- *한마디 요약: 불공변성, 와일드카드의 읽기 전용 제한*

---

**컴파일 에러 메시지 분석**

이 컴파일 에러는 제네릭 와일드카드의 제한으로 인해 발생한다. 여기에서 문제는 `newList.addAll(list2)` 라인에서 `List<? extends Product>` 가 불변 리스트처럼 동작하기 때문이다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5acd76f4-c396-45b0-9dd0-0f39ee72bbee/6851c4ad-7091-461b-b4fc-8a6c6d7643a2/image.png)

```mathematica
java.util.List<capture#1 of ? extends Product> cannot be converted to java.util.Collection<? extends Product>
```

- `capture#1` 은 컴파일러가 와일드카드 타입을 내부적으로 처리하는 방식이다.
- 컴파일러는 `list2` 의 타입(`List<? extends Product>)`이 `newList.addAll()` 에 적합하지 않다고 판단한다.

이를 해결하기 위해서는 와일드카드를 사용하지 않고 제네릭 타입 파라미터를 사용해야 한다. 제네릭 메서드로 변환하면 타입 안정성과 확장성이 향상된다.

---

**제네릭 메서드로 개선하기**

타입 안정성과 확장성을 고려하여 와일드카드를 제거하고 제네릭 메서드로 변경한다.

이 메서드는 제네릭 타입 파라미터 `T` 를 사용하며, `T` 는 `Product` 클래스 또는 이를 상속하는 하위 클래스만 허용한다.

```java
public static <T extends Product> List<T> mergeLists(
    List<T> list1,
    List<T> list2
) {
    List<T> newList = new ArrayList<>(list1); // list1 내용을 복사
    newList.addAll(list2); // list2 내용을 추가
    return newList;
}
```

---

**변경된 메서드의 작동 완리**

1. 제네릭 타입 파라미터 `<T extends Product>`
    - 타입 파라미터 `T`는 `Product` 또는 그 하위 클래스만 허용한다.
    - 이를 통해 `list1`과 `list2`가 동일한 타입 `T`를 가지도록 보장하여 타입 안정성을 확보한다.
2. 병합 로직
    - `new ArrayList<>(list1)`을 통해 `list1`의 내용을 새 리스트로 복사한다.
    - `addAll(list2)`로 `list2`의 모든 요소를 추가한다.
    - 최종 병합된 리스트를 반환한다.
3. 리턴 타입 `List<T>`
    - 반환되는 리스트는 입력과 동일한 타입 `T`의 요소들을 포함한다.
    - 별도의 타입 캐스팅 없이 안전하게 사용할 수 있다.

---

**변경 후 장점**

1. 타입 안정성
    - 컴파일 시점에서 서로 다른 리스트 타입을 감지하여 오류를 방지한다.
    - 런타임에서 별도의 타입 캐스팅이 필요하지 않다.
2. 재사용성
    - 다양한 `Product` 타입의 리스트를 동일한 병합 로직으로 처리할 수 있다.
3. 명확성
    - 메서드가 `Product`와 그 하위 타입만을 처리한다는 의도를 명확하게 표현한다.

---

**제네릭 메서드 사용 시 유의사항**

1. 타입 일관성
    - 두 입력 리스트(`list1`, `list2`)는 반드시 동일한 타입이어야 한다.
    - 서로 다른 타입의 리스트를 병합할 때는 별도의 변환 로직을 구현해야 한다.
2. 컴파일 타임 타입 체크
    - 제네릭은 컴파일 시점에 타입을 검사하여 런타임의 `ClassCastException`을 사전에 방지한다.
    - 타입 오류를 컴파일 단계에서 즉시 발견할 수 있다.

---

**와일드카드 vs 제네릭 메서드**

| **구분** | **와일드카드(? extends)** | **제네릭 메서드** |
| --- | --- | --- |
| **목적** | 읽기 전용 (요소 추가 금지) | 읽기/쓰기 모두 가능 |
| **타입 안정성** | 불완전 (추가 작업 시 에러 발생 가능) | 완전 (타입 강제하여 안전성 보장) |
| **확장성** | 제한적 (유연성 부족) | 우수 (다양한 타입 지원) |
| **사용성** | 타입 캐스팅 필요 | 타입 캐스팅 불필요 |

와일드카드는 읽기 전용으로 설계되어 있기 때문에, 병합처럼 쓰기 작업이 필요한 경우에는 제네릭 메서드로 바꿔야 한다. 

제네릭 메서드는 입력 리스트의 타입을 강제해 더 안전하고 확장성이 높은 설계를 제공한다.

---

**불공변성이란?**

Java 제네릭에서 불공변성은 제네릭 타입이 서로 상속 관계에 있어도, 제네릭 타입 자체는 상속 관계로 간주되지 않는다는 것을 의미한다.

- 클래스 상속 관계와는 다르게 제네릭 타입 간에는 별도의 상속 관계가 없다.
- `List<Parent>` 와 `List<Child>` 는 서로 아무 관계가 없다.
- `Parent`와 `Child` 가 상속 관계에 있더라도, `List<Parent>`와 `List<Child>` 는 별개의 타입으로 취급된다.


## 박대신
### 이론문제

---

### 코드문제


## 이석운
### 이론문제

---

### 코드문제

## 황진영
### 이론문제

---

### 코드문제
